// Copyright 2025 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s2

// RegionTermIndexer is a helper type for adding spatial data to an
// information retrieval system. Such systems work by converting documents
// into a collection of "index terms" (e.g., representing words or phrases),
// and then building an "inverted index" that maps each term to a list of
// documents (and document positions) where that term occurs.
//
// This type deals with the problem of converting spatial data into index
// terms, which can then be indexed along with the other document information.
type RegionTermIndexer struct {
	Options RegionTermIndexerOptions
	coverer *RegionCoverer
}

// RegionTermIndexerOptions controls the tradeoffs between index size, query
// size, and accuracy.
type RegionTermIndexerOptions struct {
	// MaxCells controls the maximum number of cells when approximating each region.
	// Default is 8.
	MaxCells int

	// MinLevel controls the minimum size of the S2Cells used to approximate regions.
	// Default is 4.
	MinLevel int

	// MaxLevel controls the maximum size of the S2Cells used to approximate regions.
	// Default is 16.
	MaxLevel int

	// LevelMod allows the effective branching factor of the S2Cell hierarchy to be
	// increased by skipping some levels. Only cells where (level - MinLevel) is a
	// multiple of LevelMod will be used.
	// Default is 1.
	LevelMod int

	// IndexContainsPointsOnly should be set to true if the index will only contain
	// points (rather than regions). This will generate smaller and faster queries
	// that are specialized for the points-only case.
	// Default is false.
	IndexContainsPointsOnly bool

	// OptimizeForSpace should be set to true if the index should be optimized for
	// space rather than for query time. This reduces the number of index terms
	// and increases the number of query terms.
	// Default is false.
	OptimizeForSpace bool

	// Marker is a non-alphanumeric character that is used internally to distinguish
	// between two different types of terms (by adding this character).
	// Default is '$'.
	Marker byte
}

// DefaultRegionTermIndexerOptions returns the default options for RegionTermIndexer.
func DefaultRegionTermIndexerOptions() RegionTermIndexerOptions {
	return RegionTermIndexerOptions{
		MaxCells: 8,
		MinLevel: 4,
		MaxLevel: 16,
		LevelMod: 1,
		Marker:   '$',
	}
}

// NewRegionTermIndexer creates a new RegionTermIndexer with the given options.
func NewRegionTermIndexer(opts RegionTermIndexerOptions) *RegionTermIndexer {
	return &RegionTermIndexer{
		Options: opts,
		coverer: &RegionCoverer{
			MinLevel: opts.MinLevel,
			MaxLevel: opts.MaxLevel,
			LevelMod: opts.LevelMod,
			MaxCells: opts.MaxCells,
		},
	}
}

func (o RegionTermIndexerOptions) trueMaxLevel() int {
	if o.LevelMod == 1 {
		return o.MaxLevel
	}
	return o.MaxLevel - (o.MaxLevel-o.MinLevel)%o.LevelMod
}

type termType int

const (
	termTypeAncestor termType = iota
	termTypeCovering
)

func (r *RegionTermIndexer) getTerm(t termType, id CellID, prefix string) string {
	if t == termTypeAncestor {
		return prefix + id.ToToken()
	}
	return prefix + string(r.Options.Marker) + id.ToToken()
}

// GetIndexTerms converts the given region into a set of terms for indexing.
//
// "prefix" is a unique prefix used to distinguish S2 terms from other terms
// in the repository.
func (r *RegionTermIndexer) GetIndexTerms(region Region, prefix string) []string {
	// Update coverer options in case they changed.
	r.coverer.MinLevel = r.Options.MinLevel
	r.coverer.MaxLevel = r.Options.MaxLevel
	r.coverer.LevelMod = r.Options.LevelMod
	r.coverer.MaxCells = r.Options.MaxCells

	covering := r.coverer.Covering(region)
	return r.GetIndexTermsForCanonicalCovering(covering, prefix)
}

// GetIndexTermsForPoint is a convenience method that accepts a Point rather than Region.
// It is faster than GetIndexTerms.
func (r *RegionTermIndexer) GetIndexTermsForPoint(point Point, prefix string) []string {
	id := cellIDFromPoint(point)
	var terms []string

	// The last cell generated by this loop is effectively the covering for
	// the given point. You might expect that this cell would be indexed as a
	// covering term, but as an optimization we always index these cells as
	// ancestor terms only. This is possible because query regions will never
	// contain a descendant of such cells.
	for level := r.Options.MinLevel; level <= r.Options.MaxLevel; level += r.Options.LevelMod {
		terms = append(terms, r.getTerm(termTypeAncestor, id.Parent(level), prefix))
	}
	return terms
}

// GetIndexTermsForCanonicalCovering returns index terms for a given S2CellUnion covering.
// The covering must satisfy the S2RegionCoverer options for this class.
func (r *RegionTermIndexer) GetIndexTermsForCanonicalCovering(covering CellUnion, prefix string) []string {
	var terms []string
	if r.Options.IndexContainsPointsOnly {
		// If the index contains points only, we shouldn't be indexing regions.
		// (This logic mirrors the C++ check).
		// In Go we can't easily CHECK failure, so we just proceed, but this configuration is invalid.
	}

	trueMaxLevel := r.Options.trueMaxLevel()
	var prevID CellID

	for _, id := range covering {
		level := id.Level()
		if level < trueMaxLevel {
			// Add a covering term for this cell.
			terms = append(terms, r.getTerm(termTypeCovering, id, prefix))
		}
		if level == trueMaxLevel || !r.Options.OptimizeForSpace {
			// Add an ancestor term for this cell at the constrained level.
			terms = append(terms, r.getTerm(termTypeAncestor, id.Parent(level), prefix))
		}
		// Finally, add ancestor terms for all the ancestors of this cell.
		for {
			level -= r.Options.LevelMod
			if level < r.Options.MinLevel {
				break
			}
			ancestorID := id.Parent(level)
			if prevID != 0 && prevID.Level() > level && prevID.Parent(level) == ancestorID {
				break // We have already processed this cell and its ancestors.
			}
			terms = append(terms, r.getTerm(termTypeAncestor, ancestorID, prefix))
		}
		prevID = id
	}
	return terms
}

// GetQueryTerms converts a given query region into a set of terms. If you compute the
// union of all the documents associated with these terms, the result will
// include all documents whose index region intersects the query region.
func (r *RegionTermIndexer) GetQueryTerms(region Region, prefix string) []string {
	// Update coverer options in case they changed.
	r.coverer.MinLevel = r.Options.MinLevel
	r.coverer.MaxLevel = r.Options.MaxLevel
	r.coverer.LevelMod = r.Options.LevelMod
	r.coverer.MaxCells = r.Options.MaxCells

	covering := r.coverer.Covering(region)
	return r.GetQueryTermsForCanonicalCovering(covering, prefix)
}

// GetQueryTermsForPoint is a convenience method that accepts a Point rather than Region.
// It is faster than GetQueryTerms.
func (r *RegionTermIndexer) GetQueryTermsForPoint(point Point, prefix string) []string {
	id := cellIDFromPoint(point)
	var terms []string

	// Recall that all trueMaxLevel cells are indexed only as ancestor terms.
	level := r.Options.trueMaxLevel()
	terms = append(terms, r.getTerm(termTypeAncestor, id.Parent(level), prefix))
	if r.Options.IndexContainsPointsOnly {
		return terms
	}

	// Add covering terms for all the ancestor cells.
	for {
		if level < r.Options.MinLevel {
			break
		}
		terms = append(terms, r.getTerm(termTypeCovering, id.Parent(level), prefix))
		level -= r.Options.LevelMod
	}

	return terms
}

// GetQueryTermsForCanonicalCovering returns query terms for a given S2CellUnion covering.
// The covering must satisfy the S2RegionCoverer options for this class.
func (r *RegionTermIndexer) GetQueryTermsForCanonicalCovering(covering CellUnion, prefix string) []string {
	var terms []string
	trueMaxLevel := r.Options.trueMaxLevel()
	var prevID CellID

	for _, id := range covering {
		level := id.Level()

		// Cells in the covering are always queried as ancestor terms.
		terms = append(terms, r.getTerm(termTypeAncestor, id, prefix))

		// If the index only contains points, there are no covering terms.
		if r.Options.IndexContainsPointsOnly {
			continue
		}

		// If we are optimizing for index space rather than query time, cells are
		// also queried as covering terms (except for trueMaxLevel cells,
		// which are indexed and queried as ancestor cells only).
		if r.Options.OptimizeForSpace && level < trueMaxLevel {
			terms = append(terms, r.getTerm(termTypeCovering, id, prefix))
		}

		// Finally, add covering terms for all the ancestors of this cell.
		for {
			level -= r.Options.LevelMod
			if level < r.Options.MinLevel {
				break
			}
			ancestorID := id.Parent(level)
			if prevID != 0 && prevID.Level() > level && prevID.Parent(level) == ancestorID {
				break // We have already processed this cell and its ancestors.
			}
			terms = append(terms, r.getTerm(termTypeCovering, ancestorID, prefix))
		}
		prevID = id
	}
	return terms
}
